{
  "hash": "1fe11b2137a79ce3529a677e68d9311b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"A Ciw Implementation of SimPy's Clock Example\"\nauthor: \"Galen Seilis\"\ndate: \"2023-12-19\"\ncategories: [Python, Discrete Event Simulation, Ciw, SimPy]\necho: true\n---\n\n\n## Introduction\n\nThis post looks at implementing a simple simulation described in the SImPy documentation using the Ciw Python package.\n\n## SimPy Simulation\n\nOn the home page of the [SimPy](https://simpy.readthedocs.io/en/latest/) documentation there is an example of a clock:\n\n::: {#f54981b1 .cell execution_count=1}\n``` {.python .cell-code}\nimport simpy\ndef clock(env, name, tick):\n    while True:\n        print(name, env.now)\n        yield env.timeout(tick)\n\nenv = simpy.Environment()\n\nenv.process(clock(env, 'fast', 0.5))\nenv.process(clock(env, 'slow', 1))\n\nenv.run(until=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfast 0\nslow 0\nfast 0.5\nslow 1\nfast 1.0\nfast 1.5\n```\n:::\n:::\n\n\nIt involves two clocks that tick deterministically at two distinct rates. One clock ticks at a rate of 0.5 units of time. The other clock ticks at 1 unit of time. This simulation runs for two units of time total.\n\n## Ciw Simulation\n\nLet's do this in Ciw. First, we need to import Ciw, and I would also like Pandas for a later processing step.\n\n::: {#131ee0ae .cell execution_count=2}\n``` {.python .cell-code}\nfrom typing import NoReturn\n\nimport ciw\nimport pandas\n```\n:::\n\n\nWe 'could' just use the `ciw.dists.Deterministic` and a simple loop achieve the same output, but that would seem to ignore how Ciw is motivated.  Ciw is for queueing models, so let's keep to that aim. Instead of taking the easy way, let's map our understanding of the clock problem into being a queueing network problem so that we can follow the typical Ciw workflow.\n\nLet us take each clock to be a node in a queueing network. We will consider the case of two clocks as per the original example.\n\nOur clocks are not self-contained like ordinary clocks. They require an input signal to tell them when to tick. We will call these discrete units of signal \"packets\". The clocks and the inputs/outputs act as completely separate systems, so for our two clocks we can assume the following routing matrix:\n\n$$R = \\begin{bmatrix}0 & 0 \\\\ 0 & 0 \\end{bmatrix}$$\n\nwhich means that packets that are used at a clock are never seen again. They leave, or are consumed, or... something. ðŸ‘»\n\nSuch a routing matrix can be tersely written in Python as a nested list:\n\n::: {#546693d8 .cell execution_count=3}\n``` {.python .cell-code}\nrouting = [[0.0] * 2] * 2\n```\n:::\n\n\nThe servers at each clock are some component of the clock that make it tick, called a \"ticker\". ðŸ˜‰ Each clock has only one ticker. For Ciw, this means that each node has only one server, which we can represent in a list:\n\n::: {#233b2646 .cell execution_count=4}\n``` {.python .cell-code}\nnumber_of_tickers = [1, 1]\n```\n:::\n\n\nWe can treat each completed tick of these clocks as the completion of a service. Each clock completes a tick at an exact deterministic rate, so the inter-arrival times of ticks are [constant random variables](https://en.wikipedia.org/wiki/Degenerate_distribution#Constant_random_variable).We can think of these service times mathematically as\n\n$$T_{\\text{service}} \\sim \\delta \\left( s \\right)$$\n\nwhere $\\delta$ is the [Dirac delta distribution](https://en.wikipedia.org/wiki/Dirac_delta_function) and $s$ the \"speed parameter\" for the clock's ticks. We can store our clock speeds in a list:\n\n::: {#d2509229 .cell execution_count=5}\n``` {.python .cell-code}\nclock_speeds = [0.5, 1]\n```\n:::\n\n\nIn order to ensure that each ticker has a correctly-timed packet we must consider the arrival times of packets onto the queue. If we provide too few packets then the clock won't keep time; ticks will be delayed. If we provide more packets than necessary then we will start to have a queue filling up with packets which is a waste of memory. Instead we should have packets arrive at the same rate that they are needed. Thus the arrival rate will also equal:\n\n$$T_{\\text{arrivals}} \\sim \\delta \\left( s \\right)$$\n\nBecause the order of the packets doesn't matter, the [service discipline](https://en.wikipedia.org/wiki/Network_scheduler)doesn't either. We'll allow Ciw to use its default of first-come, first-serve, but it wouldn't matter if we used something else.\n\nJust because we have the rates of change correct doesn't mean that we are starting in the correct state. The last, and trickiest, business of this exercise is to start the system with the correct number of packets. If it takes $s$ units of time for a packet to arrive and it takes another $s$ units of time for a packet to be processed into a tick, then each packet has a sojourn time of $2s$. Which means that at the start of the simulation there will be a delay before the clocks start ticking. We could chalk this up to simulation [warm-up](https://ciw.readthedocs.io/en/latest/Tutorial-I/tutorial_iv.html), but let's get this right. What we can do is have a distribution that\n\n$$f(t; s, c, \\ell) = \\begin{cases} \\delta \\left( 0 \\right) & t \\leq 0 \\land c < \\ell \\\\ \\delta \\left( s \\right) & \\text{Otherwise} \\end{cases}$$\n\nwhere $t$ is the simulation time, $c \\in \\mathbb{N}_0$ is a count of how many times the distribution has been used at or before $t = 0$, and $\\ell \\in \\mathbb{N}_0$  is the maximum number of times that we will allow this distribution to be used for $t \\leq 0$. Kinda weird, right? What it specifies is that we can pass packets into the system that take zero units of time to arrive and zero units of time to process. That will allow us to have a couple of packets run straight away! One implementation of Python for this looks like this:\n\n::: {#97e1007a .cell execution_count=6}\n``` {.python .cell-code}\nclass IASDeterministic(ciw.dists.Distribution):\n    \"\"\"\n    Represents an \"instant at start\" (IAS) deterministic distribution.\n\n    This distribution generates values based on an initial value, and it can be limited\n    to a specified number of samples to be initially generated.\n\n    Parameters:\n        value (float): The fixed value to be returned by the distribution.\n        limit (int, optional): The maximum number of samples to be initially generated. Defaults to 1.\n\n    Attributes:\n        value (float): The fixed value to be returned by the distribution.\n        count (int): The current count of samples generated.\n        limit (int): The maximum number of samples to be initially generated.\n\n    Methods:\n        sample(t=None, ind=None):\n            Generates a sample from the distribution.\n\n    Example:\n        >>> dist = IASDeterministic(value=3.14, limit=2)\n        >>> dist.sample(0)\n        0\n        >>> dist.sample(0)\n        0\n        >>> dist.sample(0)\n        3.14\n    \"\"\"\n\n    def __init__(self, value: float, limit: float = 1) -> NoReturn:\n        \"\"\"\n        Initializes the IASDeterministic distribution with the given parameters.\n\n        Parameters:\n            value (float): The fixed value to be returned by the distribution.\n            limit (int, optional): The maximum number of samples to be initially generated. Defaults to 1.\n        \"\"\"\n        self.value = value\n        self.count = 0\n        self.limit = limit\n\n    def sample(self, t:float = None, ind: ciw.Individual = None) -> float:\n        \"\"\"\n        Generates a sample from the distribution.\n\n        Parameters:\n            t (float, optional): Time parameter, not used in this distribution.\n            ind (int, optional): Index parameter, not used in this distribution.\n\n        Returns:\n            float: The fixed value if conditions are met; otherwise, returns None.\n        \"\"\"\n        if t  <= 0 and self.count < self.limit:\n            self.count += 1\n            return 0\n        else:\n            return self.value\n\n    def __repr__(self):\n        return f\"IASDistribution(value={self.value}, limit={self.limit})\"\n```\n:::\n\n\nOkay, that's a decent chunk of code but it is mostly just docstrings. All it does is initialize the system as we discussed. We can make one of these for each node's arrival and service distributions:\n\n::: {#2148d458 .cell execution_count=7}\n``` {.python .cell-code}\narrival_dists = [IASDeterministic(speed, 2) for speed in clock_speeds]\nservice_dists = [IASDeterministic(speed) for speed in clock_speeds]\n```\n:::\n\n\nYou may have noticed that for arrival distributions that we put the limit at two packets rather than 1. This is because we need one packet to be processed at $t=0$ but also have another ready at $t=0$ to begin service using the post-initialization rate.\n\nIf you have not used Ciw before, you may be wondering how we put these pieces together. In Ciw everything about the design of the queueing network goes into the `ciw.create_network` function.\n\n::: {#7b875c53 .cell execution_count=8}\n``` {.python .cell-code}\nnetwork = ciw.create_network(\n    arrival_distributions = arrival_dists,\n    service_distributions = service_dists,\n    number_of_servers = number_of_tickers,\n    routing = routing\n    )\n```\n:::\n\n\nNow we can instantiate our simulation and run it for two units of time:\n\n```python\nsimulation = ciw.Simulation(network)\nsimulation.simulate_until_max_time(2)\n```\n\nThe simulation instance has collected records about the completed packets. Let's stick that in a Pandas dataframe, and then we'll print out the results to a markdown table.\n\n```python\nfrom IPython.display import Markdown, display\n\nrecords = pd.DataFrame(simulation.get_all_records())\ndisplay(Markdown(records[['node', 'exit_date']].to_markdown(index=False)))\n```\n\n|   node |   exit_date |\n|-------:|------------:|\n|      1 |         0   |\n|      2 |         0   |\n|      1 |         0.5 |\n|      2 |         1   |\n|      1 |         1   |\n|      1 |         1.5 |\n\nNote that node 1 corresponds to the fast clock, and node 2 corresponds to the slow clock. That's it. We did it.\n\n\n## Conclusions\n\nCiw can definitely handle this toy simulation of a pair of clocks, but it is not the most naturally suited tool for this example. It is a bit like coordinating the [BFG-10000](https://doom.fandom.com/wiki/BFG-10000) to take aim at a squirrel; more work than needed but gets the job done.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}