{
  "hash": "43e0d09cfd3a56ec8ab9bcfb967fab2e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Executable Rust Code in Quarto\"\nauthor: \"Galen Seilis\"\ndate: \"2024-07-26\"\ncategories: [Quarto, Rust, Lua, Pandoc]\necho: false\nfilters:\n    - rust-executor.lua\n---\n\n\nThe following is a Lua filter which looks through a `qmd` file for Rust code associated with `{rust}`, compiles that code using `rustc`, runs the compiled Rust program and collects its output, and inserts the output to be rendered by pandoc.\n\n```lua\nlocal io = require(\"io\")\nlocal os = require(\"os\")\nlocal tempfile = require(\"os\").tmpname\nlocal log_file\n\n-- Function to initialize the log file\nlocal function init_log()\n  log_file = io.open(\"rust_executor_debug.log\", \"w\")\nend\n\n-- Function to log messages to file and stderr\nlocal function log(...)\n  local args = {...}\n  for i = 1, #args do\n    args[i] = tostring(args[i])\n  end\n  local message = table.concat(args, \" \")\n  if log_file then\n    log_file:write(message .. \"\\n\")\n    log_file:flush()\n  end\n  io.stderr:write(message .. \"\\n\")\n  io.stderr:flush()\nend\n\n-- Helper function to execute Rust code and return the output\nlocal function execute_rust_code(code)\n  local temp_file = tempfile() .. \".rs\"\n  log(\"Temporary Rust file:\", temp_file)\n  local source_file, err = io.open(temp_file, \"w\")\n  if not source_file then\n    log(\"Failed to create source file:\", err)\n    error(\"Failed to create source file: \" .. err)\n  end\n\n  source_file:write(code)\n  source_file:close()\n\n  local temp_bin = tempfile()\n  log(\"Temporary binary file:\", temp_bin)\n\n  local compile_command = \"rustc \" .. temp_file .. \" -o \" .. temp_bin .. \" 2>&1\"\n  log(\"Compile Command:\", compile_command)\n  local compile_pipe = io.popen(compile_command)\n  local compile_output = compile_pipe:read(\"*a\")\n  local compile_result = compile_pipe:close()\n\n  if compile_result ~= true then\n    os.remove(temp_file)\n    log(\"Rust compilation failed. Output:\", compile_output)\n    error(\"Rust compilation failed. Output: \" .. compile_output)\n  end\n\n  local exec_command = temp_bin .. \" 2>&1\"\n  log(\"Exec Command:\", exec_command)\n  local exec_pipe = io.popen(exec_command)\n  local output = exec_pipe:read(\"*a\")\n  exec_pipe:close()\n\n  local ok, rm_err = pcall(function()\n    os.remove(temp_file)\n    os.remove(temp_bin)\n  end)\n  if not ok then\n    log(\"Failed to clean up temporary files:\", rm_err)\n    error(\"Failed to clean up temporary files: \" .. rm_err)\n  end\n\n  log(\"Output:\", output)\n  return output\nend\n\nlocal echo_global = true\n\nfunction Meta(meta)\n  if meta.echo ~= nil then\n    echo_global = pandoc.utils.stringify(meta.echo) == \"true\"\n  end\nend\n\n-- Lua filter function\nfunction CodeBlock(elem)\n  if not log_file then\n    init_log()\n  end\n\n  local is_rust_code = elem.attr.classes:includes(\"{rust}\")\n  if is_rust_code then\n    log(\"Processing Rust code block\")\n    local output = execute_rust_code(elem.text)\n    output = output:gsub(\"%s+$\", \"\")\n    local blocks = {}\n\n    if echo_global then\n      -- Render Rust code as a formatted block\n      table.insert(blocks, pandoc.CodeBlock(elem.text, {class=\"rust\"}))\n    end\n\n    -- Always return the output\n    table.insert(blocks, pandoc.Para(pandoc.Str(output)))\n\n    return blocks\n  else\n    log(\"Skipping non-Rust code block\")\n  end\nend\n\n-- Ensure log file is closed properly at the end\nfunction Pandoc(doc)\n  if log_file then\n    log_file:close()\n  end\n  return doc\nend\n```\n\nLet's try some examples.\n\nHere is some Rust code that will be executed and rendered.\n\n\n```{rust}\nfn main() {\n        println!(\"Galen Seilis is learning Rust!\");\n        println!(\"Time to get Rusty!\");\n}\n```\n\n\nNow let us try some Rust code that will not be executed.\n\n\n```rust\nfn main() {\n    println!(\"Meow\");\n}\n```\n\nNow let us run a longer example from [Rust by Example](https://doc.rust-lang.org/rust-by-example/primitives/literals.html).\n\n\n```{rust}\nfn main() {\n    // Integer addition\n    println!(\"1 + 2 = {}\", 1u32 + 2);\n\n    // Integer subtraction\n    println!(\"1 - 2 = {}\", 1i32 - 2);\n    // TODO ^ Try changing `1i32` to `1u32` to see why the type is important\n\n    // Scientific notation\n    println!(\"1e4 is {}, -2.5e-3 is {}\", 1e4, -2.5e-3);\n\n    // Short-circuiting boolean logic\n    println!(\"true AND false is {}\", true && false);\n    println!(\"true OR false is {}\", true || false);\n    println!(\"NOT true is {}\", !true);\n\n    // Bitwise operations\n    println!(\"0011 AND 0101 is {:04b}\", 0b0011u32 & 0b0101);\n    println!(\"0011 OR 0101 is {:04b}\", 0b0011u32 | 0b0101);\n    println!(\"0011 XOR 0101 is {:04b}\\n\\n\\n\", 0b0011u32 ^ 0b0101);\n    println!(\"1 << 5 is {}\", 1u32 << 5);\n    println!(\"0x80 >> 2 is 0x{:x}\", 0x80u32 >> 2);\n\n    // Use underscores to improve readability!\n    println!(\"One million is written as {}\", 1_000_000u32);\n}\n```\n\n\nIn the current state there are a couple of glaring issues I have with this implementation. The first is that Rust code blocks will be run regardless of whether `echo: false` is used. The second is that all the outputs are being rendered on a single, notwithstanding Quarto's line wrapping. \n\nThere is also an enhancement which is desirable, which is to render other types of things from Rust that are not just plaintext. Instead of developing this kind of functionality myself, it would make sense to take a closer look at integrating tools such as the [Evcxr Jupyter kernel](https://github.com/evcxr/evcxr/blob/main/evcxr_jupyter/README.md).\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}