{
  "hash": "a3bb1ecece36b0b5abcb111235ff2ed3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Executable Rust Code in Quarto\"\nauthor: \"Galen Seilis\"\ndate: \"2024-07-26\"\ncategories: [Quarto, Rust, Lua, Pandoc]\necho: false\n---\n\n\n::: {.callout-warning}\n## WIP\n\nThis post is a work in progress. I am experimenting with rendering Rust code. It still needs some work.\n:::\n\n\nHere is some Rust code that will be executed and rendered.\n\n\n```{rust}\nfn main() {\n        println!(\"Galen Seilis is learning Rust!\");\n        println!(\"Time to get Rusty!\");\n}\n```\n\n\nNow let us try some Rust code that will not be executed.\n\n\n```rust\nfn main() {\n    println!(\"Meow\");\n}\n```\n\nNow let us run a longer example from [Rust by Example](https://doc.rust-lang.org/rust-by-example/primitives/literals.html).\n\n\n```{rust}\nfn main() {\n    // Integer addition\n    println!(\"1 + 2 = {}\", 1u32 + 2);\n\n    // Integer subtraction\n    println!(\"1 - 2 = {}\", 1i32 - 2);\n    // TODO ^ Try changing `1i32` to `1u32` to see why the type is important\n\n    // Scientific notation\n    println!(\"1e4 is {}, -2.5e-3 is {}\", 1e4, -2.5e-3);\n\n    // Short-circuiting boolean logic\n    println!(\"true AND false is {}\", true && false);\n    println!(\"true OR false is {}\", true || false);\n    println!(\"NOT true is {}\", !true);\n\n    // Bitwise operations\n    println!(\"0011 AND 0101 is {:04b}\", 0b0011u32 & 0b0101);\n    println!(\"0011 OR 0101 is {:04b}\", 0b0011u32 | 0b0101);\n    println!(\"0011 XOR 0101 is {:04b}\\n\\n\\n\", 0b0011u32 ^ 0b0101);\n    println!(\"1 << 5 is {}\", 1u32 << 5);\n    println!(\"0x80 >> 2 is 0x{:x}\", 0x80u32 >> 2);\n\n    // Use underscores to improve readability!\n    println!(\"One million is written as {}\", 1_000_000u32);\n}\n```\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}