{
  "hash": "ebb75a5a8fd3b791388f71e9605324b2",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Build and Run a Rust Project from Quarto Using Python\"\nauthor: \"Galen Seilis\"\ndate: \"2024-07-21\"\ncategories: [Rust, Quarto, Python]\n---\n\n\nIn a previous post I used a Lua extension to compile a Rust file using the `rustc` compiler. I ran into multiple problems. \n\nUsing `rustc` rather than Cargo means that I miss out on a lot of the build tools, and it is also less conventional for Rust projects. \n\nThere were also issues with my plugin. It did not correctly turn off echo either locally to a code block, or to the global setting in the preamble of the Quarto file. It also did not put code on a new line. Further, I got feedback that this might not be supported. I also learned from a [discussion answer](https://github.com/quarto-dev/quarto-cli/discussions/10399#discussioncomment-10178340) on the Quarto Github discussion board that there are tools that might be better.\n\nWhile other tools like [`evcxr`](https://github.com/evcxr/evcxr/) look appealing, I have not looked into how to exactly integrate it with Quarto yet. \n\nBut there is a low-hanging fruit we can take advantage of here. We can certainly use Python subprocess library to indirectly orchestrate building and running a rust project. It also allows us to capture the output as text and return that into a Jupyter notebook. So that's exaxtly what I made:\n\n```python\nimport subprocess\nimport os\nimport stat\n\ndef log_permissions(path):\n    st = os.stat(path)\n    permissions = stat.filemode(st.st_mode)\n    print(f\"Permissions for {path}: {permissions}\")\n\ndef compile_and_run_rust(target_file):\n    # Get the directory and the file name\n    target_dir = os.path.dirname(target_file)\n    target_name = os.path.basename(target_dir)  # Adjusted to get the correct target name\n\n    # Ensure Cargo.toml exists in the target directory\n    cargo_toml_path = os.path.join(target_dir, 'Cargo.toml')\n    if not os.path.exists(cargo_toml_path):\n        raise FileNotFoundError(\"Cargo.toml not found in the target directory.\")\n\n    # Compile the Rust project\n    try:\n        build_process = subprocess.run(\n            ['cargo', 'build', '--release'],\n            cwd=target_dir,\n            check=True,\n            capture_output=True,\n            text=True\n        )\n    except subprocess.CalledProcessError as e:\n        print(f\"Compilation Error: {e.stderr}\")\n        return\n\n    # Find the compiled executable\n    target_exe = os.path.join(target_dir, 'target', 'release', target_name)\n    if os.name == 'nt':\n        target_exe += '.exe'\n\n    if not os.path.exists(target_exe):\n        raise FileNotFoundError(\"Compiled executable not found.\")\n\n    if os.name != 'nt':\n        try:\n            os.chmod(target_exe, stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)\n            os.chmod(os.path.dirname(target_exe), stat.S_IRWXU | stat.S_IRWXG | stat.S_IRWXO)\n        except PermissionError as e:\n            print(f\"Error setting permissions: {e}\")\n            return\n\n    # Run the compiled executable and capture its output\n    try:\n        run_process = subprocess.run(\n            [target_exe],\n            check=True,\n            capture_output=True,\n            text=True\n        )\n        output = run_process.stdout\n        return output\n    except subprocess.CalledProcessError as e:\n        print(f\"Execution Error: {e.stderr}\")\n        return\n\n# Example usage\nif __name__ == \"__main__\":\n    output = compile_and_run_rust('../posts/rust-run-from-python/hello/main.rs')\n    print(output)\n```\n\nPython Jupyter notebooks run Python in interactive mode, so it is slightly less convenient for importing Python files. Nonetheless this can be done by inserting our script into the path using the `sys` library. Once we have imported the `run_rust` file, we can call the `compile_and_run_rust` pointing to a Rust project path that is locally stored\n\n\nLet us start a Rust project called \"hello\".\n\n```bash\ncargo init hello\n```\n\nI also added a loop with a `println` macro just so we can see how this approach handles keeping newline characters. Here is the Rust code in `hello/src/main.rs`.\n\n```rust\nfn main() {\n\n    let mut count = 0;\n\n    loop {\n        count = count + 1;\n        println!(\"{} Hello, world!\", count);\n        if count > 11 {\n            break\n        }\n    }\n}\n```\n\nThe above Rust code should print a series of lines each starting with a number, with the numbers ranging from 1 to 12.\n\nWith all that setup, we can now try using the `run_rust.compile_and_run_rust` process caller.\n\n::: {#a24612b8 .cell execution_count=1}\n``` {.python .cell-code}\nimport sys\nsys.path.insert(1, '../../scripts')\n\nimport run_rust\n\nprint(run_rust.compile_and_run_rust('./hello/'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 Hello, world!\n2 Hello, world!\n3 Hello, world!\n4 Hello, world!\n5 Hello, world!\n6 Hello, world!\n7 Hello, world!\n8 Hello, world!\n9 Hello, world!\n10 Hello, world!\n11 Hello, world!\n12 Hello, world!\n\n```\n:::\n:::\n\n\nAnd there we have it! We can further try again, but with `#| echo: false` in the Python code block to turn off echo:\n\n::: {#2f649e3e .cell execution_count=2}\n\n::: {.cell-output .cell-output-stdout}\n```\n1 Hello, world!\n2 Hello, world!\n3 Hello, world!\n4 Hello, world!\n5 Hello, world!\n6 Hello, world!\n7 Hello, world!\n8 Hello, world!\n9 Hello, world!\n10 Hello, world!\n11 Hello, world!\n12 Hello, world!\n\n```\n:::\n:::\n\n\nIn conclusion, this approach using Python itself and Python Jupyter notebooks to compile, run, and display the printed output from a Rust program. It succeeds in preserving newline characters, and echo works locally. It also works globally for the whole file.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}