{
  "hash": "e580c70e74f883993d8cf614242e32e4",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"A Ciw Implementation of SimPy's Car Example\"\nauthor: \"Galen Seilis\"\ndate: \"2023-12-20\"\ncategories: [Python, Simulation, Queueing System, Queueing Network, Queueing Theory, Routing, Process-Based Simulation, Random Variables, Constant Random Variables, Arrival Distributions, Service Distributions, Timing, Initialization, Discrete Event Simulation, Ciw, SimPy]\necho: true\n---\n\n\nIn the SimPy documentation they describe a [car process](https://simpy.readthedocs.io/en/latest/simpy_intro/basic_concepts.html#our-first-process) which involves a car which transitions between parking and driving. From being parked it takes 5 units of time to change to being in a state of driving. Similarly, it takes 2 units of time to go from being in a state of driving to a state of parkerd. Here is a state diagram representing this system:\n\n\n```{mermaid}\n%%| echo: false\nstateDiagram\n    [*] --> Parked\n    Parked --> Driving: 5\n    Driving --> Parked: 2\n    Parked --> [*]\n    Driving --> [*]\n```\n\n\nFor something this simple we don't really need discrete event simulation software, but it can be helpful for the sake of illustration to do it anyway. Let's use idiomatic Ciw to make an equivalent simulation.\n\nLet our queueing network have two nodes, each representing either of the two states \"Parked\" or \"Driving\". The car will go between these two nodes. When the car arrives at a node that will repesent that it has begun the whatever process is involved, and when the car finishes service at that node we will interpret that to mean it is now changing state.\n\nSince there will be only one car in the whole network, we do not need to give any consideration to service discipline. If the car is on the queue, then serve it. Otherwise, don't.\n\nWe do need to pay attention to arrival times however. We need the car to arrive at the first node at the start of the simulation and for no additional cars to arrive thereafter. This can be achieved with a sequential distribution available in Ciw:\n\n::: {#921cb782 .cell execution_count=1}\n``` {.python .cell-code}\nimport ciw\nciw.dists.Sequential([0, float('inf')])\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nSequential([0, inf])\n```\n:::\n:::\n\n\nThe class `ciw.dists.Sequential` takes an iterable (usually a list) representing the sequence of arrival times to be done. When it has gotten through the list it will start again at the start of the list. But here's the catch: we have set the second time to $\\infty$, which it will never reach. So there will be a single arrival at $t=0$ and non thereafter. We need to specify that no arrivals occur at the second node, which we can do using `None`:\n\n::: {#745a0f1b .cell execution_count=2}\n``` {.python .cell-code}\narrival_dists = [ciw.dists.Sequential([0, float('inf')]), None]\n```\n:::\n\n\nFor service times we know that the car will start driving after 5 units of time, then be parked for 2 units of time, and repeat. These are [constant random variables](https://en.wikipedia.org/wiki/Degenerate_distribution#Constant_random_variable) which can be specified in Ciw using `ciw.dists.Deterministic`:\n\n::: {#68ca02b9 .cell execution_count=3}\n``` {.python .cell-code}\nservice_dists = [ciw.dists.Deterministic(5), ciw.dists.Deterministic(2)]\n```\n:::\n\n\nWe don't need to, but let's add some fluff so that we get a similar printout. To do that let's write a wrapper distribution.\n\n::: {#0e9a23df .cell execution_count=4}\n```````` {.python .cell-code}\nfrom typing import NoReturn\n\nimport ciw\n\nclass PrintDistWrapper(ciw.dists.Distribution):\n    \"\"\"\n    A wrapper class for a probability distribution that adds a print statement\n    before sampling from the underlying distribution.\n\n    Parameters:\n    - dist (ciw.dists.Distribution): The underlying probability distribution to be wrapped.\n    - message (str): A custom message to be printed before sampling.\n\n    Note: This class inherits from ciw.dists.Distribution.\n\n    Example:\n    ```\n\n    underlying_dist = SomeDistributionClass(parameters)\n    wrapper_dist = PrintDistWrapper(underlying_dist, \"Sampling from the distribution:\")\n    sample_result = wrapper_dist.sample()\n    ```\n    \"\"\"\n\n    def __init__(self, dist: ciw.dists.Distribution, message: str) -> NoReturn:\n        \"\"\"\n        Initialize the PrintDistWrapper instance.\n\n        Parameters:\n        - dist (ciw.dists.Distribution): The underlying probability distribution to be wrapped.\n        - message (str): A custom message to be printed before sampling.\n        \"\"\"\n        super().__init__()\n        self.dist = dist\n        self.message = message\n\n    def sample(self, t: float = None, ind: ciw.Individual = None) -> float:\n        \"\"\"\n        Generate a sample from the underlying distribution, printing a custom message.\n\n        Parameters:\n        - t: Optional parameter (if applicable to the underlying distribution).\n        - ind: Optional parameter (if applicable to the underlying distribution).\n\n        Returns:\n        - The sampled value from the underlying distribution.\n\n        Note: This method overrides the sample method of ciw.dists.Distribution.\n        \"\"\"\n        print(self.message, t)\n        return self.dist.sample(t, ind)\n````````\n:::\n\n\nThe `PrintDistWrapper` class allows us to print whatever message we like when the distribution is sampled from. Now we can just wrap our service distributions like this:\n\n::: {#fc15d193 .cell execution_count=5}\n``` {.python .cell-code}\nservice_dists = [\n  PrintDistWrapper(\n    ciw.dists.Deterministic(5),\n    'Start parking at'),\n  PrintDistWrapper(\n    ciw.dists.Deterministic(2),\n    'Start driving at')\n    ]\n```\n:::\n\n\nWe only need one server at each node since there could only ever be one car either there, or not there, requiring service. So we can just set those number of servers in a list like this:\n\n::: {#cdb87623 .cell execution_count=6}\n``` {.python .cell-code}\nnum_servers = [1, 1]\n```\n:::\n\n\nSince we have two nodes, we need to specifying the routing behaviour. It is simple in this case, and stationary. Whenever the car is leaving node one, go to node to. Whenever the car is leaving node two, go to node one. We can specify this as the following routing matrix:\n\n$$\\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix}$$\n\nIn Ciw we can take our routing matrix to be:\n\n::: {#efd287d1 .cell execution_count=7}\n``` {.python .cell-code}\nR = [[0.0, 1.0], [1.0, 0.0]]\n```\n:::\n\n\nWe can now put together our simulation object:\n\n::: {#003ce93b .cell execution_count=8}\n``` {.python .cell-code}\nnetwork = ciw.create_network(\n    arrival_distributions = arrival_dists,\n    service_distributions = service_dists,\n    number_of_servers = num_servers,\n    routing=R\n    )\n```\n:::\n\n\nAnd put together out simulation object:\n\n::: {#934a6535 .cell execution_count=9}\n``` {.python .cell-code}\nsimulation = ciw.Simulation(network)\n```\n:::\n\n\nAnd simulate (for 15 units of time)!\n\n::: {#3fd8f644 .cell execution_count=10}\n``` {.python .cell-code}\nsimulation.simulate_until_max_time(15)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStart parking at 0\nStart driving at 5\nStart parking at 7\nStart driving at 12\nStart parking at 14\n```\n:::\n:::\n\n\nHappy simulating! :)\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}