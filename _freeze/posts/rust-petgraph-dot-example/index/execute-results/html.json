{
  "hash": "9175b05bc7e38a3f8747b202b41809ca",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Rendering a Dot Representation of a Graph in Quarto Using Petgraph and Petgraph-evcxr\"\nauthor: \"Galen Seilis\"\ndate: \"2024-08-08\"\ncategories: [Rust, Petgraph, Petgraph-evcxr, Dot]\necho: true\n---\n\n\nIn this post I want to quickly showcase the use of the use of the Petgraph and Petgraph-evcxr packages. Petgraph is a popular graph data structures and algorithms crate available for Rust. Petgraph-evcxr is a tool that makes it possible to easily visualize graphs created using Petgraph within Jupyter notebooks. This in turn allows us to visualize such graphs within Quarto.\n\nThis we need to include them as dependencies.\n\n::: {#0e4f77f8 .cell execution_count=1}\n``` {.rust .cell-code}\n:dep petgraph = \"*\"\n:dep petgraph-evcxr = \"*\"\n\nextern crate petgraph;\nuse petgraph::graph::Graph;\nuse petgraph::dot::Dot;\nuse petgraph_evcxr::{draw_graph, draw_dot};\n```\n:::\n\n\nThen we define the graph.\n\n::: {#e0d50e03 .cell execution_count=2}\n``` {.rust .cell-code}\nlet mut g : Graph<&str, &str> = Graph::new();\nlet rock = g.add_node(\"Rock\");\nlet paper = g.add_node(\"Paper\");\nlet scissors = g.add_node(\"Scissors\");\n\ng.add_edge(rock, scissors, \"beats\");\ng.add_edge(paper, rock, \"beats\");\ng.add_edge(scissors, paper, \"beats\");\n```\n:::\n\n\nFinally, we call draw the graph.\n\n::: {#065d8e3b .cell execution_count=3}\n``` {.rust .cell-code}\ndraw_graph(&g);\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](index_files/figure-html/cell-4-output-1.png){}\n:::\n:::\n\n\n::: {.callout-tip}\n\n# Mermaid is an easy alternative\n\nOne should be aware of the fact that it is easy to produce similar diagrams with Mermaid.\n\n\n```{mermaid}\nflowchart TD\n\nRock -->|Beats| Scissors\nPaper -->|Beats| Rock\nScissors -->|Beats| Paper\n```\n\n\nPerhaps a small advantage of using Petgraph here is that you can programmatically generate the properties of the diagram, as other tools such as `networkx` would let us do. Above I just wanted to show that we 'can' produce such diagrams starting with Rust.\n:::\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}