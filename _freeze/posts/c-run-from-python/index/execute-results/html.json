{
  "hash": "a6edd97492521a1223afff6d157f0481",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Build and Run a C Project from Quarto Using Python\"\nauthor: \"Galen Seilis\"\ndate: \"2024-07-30\"\ncategories: [C, Quarto, Python, subprocess]\n---\n\n\n\n\nIn this post I share a way to compile and run a C file using Python, which in turn can be used to render the output of the C program in Quarto.\n\n## Python Script\n\nThe Python script I developed is similar to the one I made for Rust, except that it does two phases. First `gcc -c file.c` is run on each file in a target path. Then `gcc -o program main.o file1.o ...` is run to put together the final program with appropriate linking.\n\n```python\nimport subprocess\nimport os\nimport glob\nimport stat\n\ndef log_permissions(path):\n    st = os.stat(path)\n    permissions = stat.filemode(st.st_mode)\n    print(f\"Permissions for {path}: {permissions}\")\n\ndef compile_and_run_c(project_dir):\n    project_dir = os.path.abspath(project_dir)\n\n    # Find all .c files in the project directory\n    c_files = glob.glob(os.path.join(project_dir, '*.c'))\n    if not c_files:\n        raise FileNotFoundError(\"No C source files found in the project directory.\")\n\n    object_files = []\n\n    # Compile each .c file into an object file\n    for c_file in c_files:\n        obj_file = os.path.splitext(c_file)[0] + '.o'\n        try:\n            compile_process = subprocess.run(\n                ['gcc', '-c', c_file, '-o', obj_file],\n                cwd=project_dir,\n                check=True,\n                capture_output=True,\n                text=True\n            )\n            object_files.append(obj_file)\n        except subprocess.CalledProcessError as e:\n            print(f\"Compilation Error for {c_file}: {e.stderr}\")\n            return\n\n    # Determine the name of the executable (assuming the file with main is called main.c)\n    exe_name = 'program'\n    main_file = os.path.join(project_dir, 'main.c')\n    if os.path.exists(main_file):\n        exe_name = os.path.splitext(os.path.basename(main_file))[0]\n\n    # Link all object files into a single executable\n    try:\n        link_process = subprocess.run(\n            ['gcc', '-o', exe_name] + object_files,\n            cwd=project_dir,\n            check=True,\n            capture_output=True,\n            text=True\n        )\n    except subprocess.CalledProcessError as e:\n        print(f\"Linking Error: {e.stderr}\")\n        return\n\n    # Find the compiled executable\n    target_exe = os.path.join(project_dir, exe_name)\n\n    if not os.path.exists(target_exe):\n        raise FileNotFoundError(\"Compiled executable not found.\")\n\n    # Set the executable permissions\n    try:\n        os.chmod(target_exe, stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)\n    except PermissionError as e:\n        print(f\"Error setting permissions: {e}\")\n        return\n\n    # Run the compiled executable and capture its output\n    try:\n        run_process = subprocess.run(\n            [target_exe],\n            check=True,\n            capture_output=True,\n            text=True\n        )\n        output = run_process.stdout\n        return output\n    except subprocess.CalledProcessError as e:\n        print(f\"Execution Error: {e.stderr}\")\n        return\n\n# Example usage\nif __name__ == \"__main__\":\n    output = compile_and_run_c('../posts/c-run-from-python/hello')\n    print(output)\n```\n\nLet's see it in action.\n\n## Single File Example\n\n::: {#3671593f .cell execution_count=1}\n``` {.python .cell-code}\nimport sys\nsys.path.insert(1, '../../scripts')\n\nimport run_c\n\nprint(run_c.compile_and_run_c('./hello/'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1 Hello, world!\n2 Hello, world!\n3 Hello, world!\n4 Hello, world!\n5 Hello, world!\n6 Hello, world!\n7 Hello, world!\n8 Hello, world!\n9 Hello, world!\n10 Hello, world!\n11 Hello, world!\n12 Hello, world!\n\n```\n:::\n:::\n\n\nIn the above example I am only compiling and running a single C file, but it is certainly possible to compile multiple files with a further change. For each `.c` file in the project path, I could run `gcc -c file.c` on each file. Then I could run `gcc -o program main.o file1.o file2.o`. This way I can link the object files together.\n\n## Linked Files Example\n\nIn this example I define a `main.c` source file, and a couple of `helper<#>.c` source files along with their header files.\n\n```c\n// main.c\n#include <stdio.h>\n#include \"helper1.h\"\n#include \"helper2.h\"\n\nint main() {\n    printf(\"Starting program...\\n\");\n    helper1();\n    helper2();\n    printf(\"Program finished.\\n\");\n    return 0;\n}\n```\n\n```c\n// helper1.c\n#include <stdio.h>\n#include \"helper1.h\"\n\nvoid helper1() {\n    printf(\"Hello from helper1!\\n\");\n}\n```\n\n```c\n// helper1.h\n#ifndef HELPER1_H\n#define HELPER1_H\n\nvoid helper1();\n\n#endif\n```\n\n```c\n// helper2.c\n#include <stdio.h>\n#include \"helper2.h\"\n\nvoid helper2() {\n    printf(\"Hello from helper2!\\n\");\n}\n```\n\n```c\n// helper2.h\n#ifndef HELPER2_H\n#define HELPER2_H\n\nvoid helper2();\n\n#endif\n```\n\nNow we can similarly point `run_c.compile_and_rune_c` pointed at the path where these files exist.\n\n::: {#345520fb .cell execution_count=2}\n``` {.python .cell-code}\nimport sys\nsys.path.insert(1, '../../scripts')\n\nimport run_c\n\nprint(run_c.compile_and_run_c('./hello2/'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStarting program...\nHello from helper1!\nHello from helper2!\nProgram finished.\n\n```\n:::\n:::\n\n\n## Conclusions\n\nAs long as the linking and compiled options are kept simple, this script allows you to compile simple C langauge programs. This may be suitable for ensuring that C code examples for blogging actually work. Expanding into autotools and make files is the way to go for more complicated builds.\n\nThe same limitation as the corresponding script to run Rust code applies: if your `qmd` file does not change while Quarto's setting is `freeze: auto`, the page will not be rerendered if the C code changes even if the Quarto document is not changed.\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}