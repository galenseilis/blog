{
  "hash": "637af8e9c3c86a4173d6f19531816a3d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Build and Run a Zig Project from Quarto Using Python\"\nauthor: \"Galen Seilis\"\ndate: \"2024-08-09\"\ncategories: [Zig, Quarto, Python, subprocess]\n---\n\n\nIn this post I share a way to compile and run a Zig file using Python, which in turn can be used to render the output of the Zig program in Quarto.\n\n## Python Script\n\nThe Python script I developed is similar to the one I made for Rust, except that it does two phases. While Zig has a very powerful and flexible build system, I will only attempt to compile a single project file.\n\n```python\nimport subprocess\nimport os\nimport stat\n\ndef log_permissions(path):\n    st = os.stat(path)\n    permissions = stat.filemode(st.st_mode)\n    print(f\"Permissions for {path}: {permissions}\")\n\ndef find_executable(bin_dir):\n    \"\"\"Find the executable file in the given directory.\"\"\"\n    for root, dirs, files in os.walk(bin_dir):\n        for file in files:\n            file_path = os.path.join(root, file)\n            if os.access(file_path, os.X_OK):\n                return file_path\n    raise FileNotFoundError(\"No executable found in the bin directory.\")\n\ndef build_and_run_zig(project_dir):\n    project_dir = os.path.abspath(project_dir)\n\n    # Build the Zig project\n    try:\n        build_process = subprocess.run(\n            ['zig', 'build'],\n            cwd=project_dir,\n            check=True,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True\n        )\n    except subprocess.CalledProcessError as e:\n        print(f\"Build Error: {e.stderr}\")\n        return\n\n    # Find the executable in the zig-out/bin/ directory\n    bin_dir = os.path.join(project_dir, 'zig-out', 'bin')\n    if not os.path.exists(bin_dir):\n        raise FileNotFoundError(\"The bin directory does not exist after the build.\")\n    \n    exe_path = find_executable(bin_dir)\n\n    # Set the executable permissions\n    try:\n        os.chmod(exe_path, stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)\n    except PermissionError as e:\n        print(f\"Error setting permissions: {e}\")\n        return\n\n    # Run the compiled executable and print its output\n    try:\n        run_process = subprocess.run(\n            [exe_path],\n            check=True,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True\n        )\n        # print(run_process.stdout)  # Print the output from the Zig executable\n        # print(run_process.stderr)  # Print any error output\n        if run_process.stdout:\n            return run_process.stdout\n        else:\n            return run_process.stderr\n    except subprocess.CalledProcessError as e:\n        print(f\"Execution Error: {e.stderr}\")\n        return\n\n```\n\nLet's see it in action.\n\n## Single File Example\n\nHere I will define a simple \"Hello, World\" example. We can do this by creating a project folder `hello`, and calling `zig init` within it to create a default project. In the default `main.zig` I put the following Zig code.\n\n```rust\nconst std = @import(\"std\");\n\npub fn main() void {\n    std.debug.print(\"Hello, World!\\n\", .{});\n}\n```\n\n::: {.callout-caution}\nI have used Rust's syntax highlighting for the above Zig code.\n:::\n\n\nNow we can build and run our Zig project by using the earlier Python script.\n\n::: {#ff37edb9 .cell execution_count=1}\n``` {.python .cell-code}\nimport sys\nsys.path.insert(1, '../../scripts')\n\nfrom run_zig import build_and_run_zig\n\nprint(build_and_run_zig('./hello'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello, World!\n\n```\n:::\n:::\n\n\n## Conclusion\n\nWhile Zig doesn't really have a REPL (that I'm aware of), you can include its standard output in Quarto blogs using Python's Subprocess library.\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}